<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Touhou Bullet Dodge Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- Thư viện Tone.js cho âm nhạc -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Đảm bảo chiều cao tối thiểu để căn giữa */
            background-color: #1a1a2e; /* Nền tối */
            color: #e0e0e0; /* Chữ sáng */
            margin: 0;
            /* overflow: hidden; */ /* Bỏ ẩn overflow để cho phép cuộn trang nếu cần */
            padding: 20px;
            box-sizing: border-box;
        }

        .game-container {
            background-color: #2a2a4a; /* Nền container trò chơi */
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 90%; /* Giới hạn chiều rộng trên màn hình lớn */
            width: 500px; /* Chiều rộng mặc định cho desktop */
            position: relative; /* Để overlay tạm dừng hoạt động */
            overflow: hidden; /* Đảm bảo nền sao không tràn ra ngoài */
            flex-grow: 1; /* Cho phép container co giãn */
            justify-content: center; /* Căn giữa nội dung theo chiều dọc */
        }

        canvas {
            background-color: #0d0d1a; /* Nền của canvas */
            border: 3px solid #6a0572; /* Viền màu tím */
            border-radius: 10px;
            display: block;
            touch-action: none; /* Ngăn cuộn/zoom trên thiết bị cảm ứng */
            width: 100%; /* Chiều rộng linh hoạt */
            /* height sẽ được đặt bằng JS để duy trì tỷ lệ khung hình */
            position: relative;
            z-index: 1; /* Đảm bảo canvas ở trên nền sao */
        }

        .star-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            overflow: hidden;
            border-radius: 15px; /* Giống border-radius của game-container */
            z-index: 0; /* Đảm bảo nền sao ở dưới canvas */
        }

        .star {
            position: absolute;
            background-color: #fff;
            border-radius: 50%;
            opacity: 0;
            animation: twinkle 5s infinite ease-in-out;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.8; }
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 480px;
            font-size: 1.2em;
            font-weight: bold;
            color: #a0a0ff; /* Màu xanh nhạt */
            padding: 5px 0;
            border-bottom: 1px solid #4a4a6a;
            z-index: 2; /* Đảm bảo thông tin game ở trên */
        }

        .button {
            background: linear-gradient(145deg, #8a2be2, #6a0572); /* Gradient tím */
            color: white;
            border: 2px solid #a052ee; /* Viền sáng hơn */
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            flex: 1; /* Cho phép các nút co giãn */
            min-width: 120px; /* Giới hạn chiều rộng tối thiểu */
        }

        .button:hover {
            background: linear-gradient(145deg, #6a0572, #8a2be2);
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(0, 0, 0, 0.1);
        }

        .control-button {
            background-color: #4a4a6a;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 50%;
            font-size: 1.5em;
            cursor: pointer;
            touch-action: manipulation; /* Ngăn hành vi mặc định của trình duyệt */
            transition: background-color 0.2s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            width: 60px;
            height: 60px;
            flex-shrink: 0; /* Ngăn co lại */
        }

        .control-button.focus-button {
            border-radius: 8px; /* Nút focus hình chữ nhật */
            width: auto;
            height: auto;
            padding: 12px 20px;
            font-size: 1em;
            background: linear-gradient(145deg, #28a745, #218838); /* Màu xanh lá */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .control-button:active {
            background-color: #6a6a8a;
        }

        .game-over-screen, .paused-overlay, .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85); /* Nền tối hơn cho overlay */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 2em;
            text-align: center;
            z-index: 100;
            border-radius: 15px;
            gap: 20px;
            backdrop-filter: blur(5px); /* Hiệu ứng mờ nền */
        }

        .game-over-screen h2, .paused-overlay h2, .start-screen h2 {
            margin-bottom: 10px;
            color: #ff6b6b; /* Màu đỏ */
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.7);
        }

        .start-screen h2 {
            color: #a0a0ff; /* Màu xanh nhạt cho tiêu đề bắt đầu */
            text-shadow: 0 0 10px rgba(160, 160, 255, 0.7);
        }

        .game-over-screen p, .start-screen p {
            font-size: 0.8em;
            margin-bottom: 20px;
        }

        /* Container cho các nút điều khiển chính (Tạm dừng, Nhạc) */
        .main-controls-container {
            position: fixed; /* Cố định vị trí trên desktop */
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 200;
            width: 100%;
            max-width: 500px;
            padding: 0 20px;
            box-sizing: border-box;
            justify-content: center;
        }

        /* Điều chỉnh nút chơi lại trong màn hình game over */
        #gameOverScreen .button, #startScreen .button {
            min-width: 180px;
        }

        /* Styles for the virtual joystick */
        .joystick-container {
            display: none; /* Mặc định ẩn trên desktop */
            position: absolute;
            bottom: 20px; /* Vị trí dưới cùng bên trái */
            left: 20px;
            width: 120px;
            height: 120px;
            background-color: rgba(74, 74, 106, 0.7);
            border-radius: 50%;
            justify-content: center;
            align-items: center;
            touch-action: none; /* Ngăn hành vi mặc định của trình duyệt */
            z-index: 150;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
        }

        .joystick-handle {
            width: 50px;
            height: 50px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            position: absolute;
            touch-action: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* Nút focus riêng cho di động */
        #focusButton {
            display: none; /* Mặc định ẩn trên desktop */
            position: absolute;
            bottom: 20px; /* Vị trí dưới cùng bên phải */
            right: 20px;
            z-index: 150;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                min-height: auto; /* Cho phép cuộn trên di động nếu nội dung tràn */
            }
            .game-container {
                padding: 15px;
                width: 95%;
                max-width: unset; /* Bỏ giới hạn max-width cố định */
            }
            canvas {
                /* Height will be set by JS */
            }
            .game-info {
                font-size: 1em;
            }
            .game-over-screen, .paused-overlay, .start-screen {
                font-size: 1.5em;
            }
            .game-over-screen p, .start-screen p {
                font-size: 0.7em;
            }
            .button {
                padding: 10px 15px;
                font-size: 0.9em;
                min-width: unset; /* Bỏ giới hạn min-width */
            }
            .main-controls-container {
                position: static; /* Trở lại vị trí tĩnh trên di động nhỏ */
                margin-top: 20px; /* Khoảng cách với canvas */
                transform: none; /* Bỏ transform */
            }
            .joystick-container {
                display: flex; /* Hiển thị trên di động */
            }
            #focusButton {
                display: flex; /* Hiển thị trên di động */
                width: 60px; /* Kích thước nút focus */
                height: 60px;
                font-size: 1.2em;
                padding: 10px;
            }
            #focusButton.focus-button { /* Điều chỉnh kích thước cho nút focus trên di động */
                width: auto;
                height: auto;
                padding: 10px 15px;
                font-size: 0.9em;
            }
        }

        @media (max-width: 480px) {
            .game-container {
                padding: 10px;
            }
            canvas {
                /* Height will be set by JS */
            }
            .joystick-container {
                width: 100px;
                height: 100px;
            }
            .joystick-handle {
                width: 40px;
                height: 40px;
            }
            #focusButton {
                width: 50px;
                height: 50px;
                font-size: 1em;
                padding: 8px;
            }
            #focusButton.focus-button {
                padding: 8px 12px;
                font-size: 0.8em;
            }
        }

        /* Landscape mode adjustments for mobile */
        @media (orientation: landscape) and (max-height: 768px) {
            .game-container {
                flex-direction: row; /* Sắp xếp ngang trong landscape */
                flex-wrap: wrap; /* Cho phép xuống dòng nếu không đủ chỗ */
                justify-content: space-around;
                align-items: flex-start; /* Căn trên cùng */
                padding: 10px;
                gap: 10px;
            }
            canvas {
                max-width: 60%; /* Canvas chiếm tối đa 60% chiều rộng */
                height: auto; /* Chiều cao tự động điều chỉnh */
            }
            .game-info {
                flex-basis: 100%; /* Thông tin game chiếm toàn bộ chiều rộng */
                order: -1; /* Đẩy lên trên cùng */
                font-size: 0.9em;
                padding-bottom: 0;
                border-bottom: none;
            }
            .main-controls-container {
                position: static;
                transform: none;
                flex-direction: column; /* Nút tạm dừng/nhạc xếp dọc */
                width: auto;
                max-width: unset;
                padding: 0;
                gap: 5px;
                align-items: flex-start;
                margin-top: 0;
            }
            .button {
                padding: 8px 15px;
                font-size: 0.8em;
                min-width: unset;
                flex: none;
            }
            .joystick-container, #focusButton {
                position: static; /* Trở về vị trí tĩnh */
                margin: 0;
                transform: none;
                width: 80px; /* Kích thước nhỏ hơn trong landscape */
                height: 80px;
                font-size: 1em;
                align-self: center; /* Căn giữa theo chiều dọc */
            }
            .joystick-handle {
                width: 30px;
                height: 30px;
            }
            #focusButton.focus-button {
                width: auto;
                height: auto;
                padding: 8px 12px;
                font-size: 0.8em;
            }
            .game-over-screen, .paused-overlay, .start-screen {
                font-size: 1.2em; /* Kích thước chữ nhỏ hơn */
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="star-background" id="starBackground"></div>
        <h1>Touhou Bullet Dodge Game</h1>
        <div class="game-info">
            <span id="scoreDisplay">Score: 0</span>
            <span id="difficultyDisplay">Difficulty: 1</span>
            <span id="revivesDisplay">Revives: 3</span>
        </div>
        <canvas id="gameCanvas"></canvas>

        <!-- Các nút điều khiển chính -->
        <div class="main-controls-container">
            <button id="pauseButton" class="button">Pause</button>
            <button id="musicToggleButton" class="button">Toggle Music</button>
        </div>

        <!-- Joystick ảo cho di động -->
        <div class="joystick-container" id="joystickContainer">
            <div class="joystick-handle" id="joystickHandle"></div>
        </div>

        <!-- Nút focus riêng cho di động -->
        <button class="control-button focus-button" id="focusButton" aria-label="Focus">Focus</button>

        <!-- Màn hình bắt đầu game -->
        <div id="startScreen" class="start-screen">
            <h2>TOUHOU BULLET DODGE GAME</h2>
            <p>Dodge the bullets and survive as long as you can!</p>
            <button id="startButton" class="button">Start Game</button>
        </div>

        <div id="gameOverScreen" class="game-over-screen" style="display: none;">
            <h2>GAME OVER!</h2>
            <p>You survived for <span id="finalScore">0</span> seconds</p>
            <button id="restartButton" class="button">Play Again</button>
        </div>

        <div id="pausedOverlay" class="paused-overlay" style="display: none;">
            <h2>PAUSED</h2>
            <p>Press ESC or "Resume" button to continue</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const difficultyDisplay = document.getElementById('difficultyDisplay');
        const revivesDisplay = document.getElementById('revivesDisplay');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartButton = document.getElementById('restartButton');
        const pauseButton = document.getElementById('pauseButton');
        const musicToggleButton = document.getElementById('musicToggleButton');
        const pausedOverlay = document.getElementById('pausedOverlay');
        const starBackground = document.getElementById('starBackground');
        const startScreen = document.getElementById('startScreen'); // Màn hình bắt đầu
        const startButton = document.getElementById('startButton'); // Nút bắt đầu

        // Joystick elements
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickHandle = document.getElementById('joystickHandle');
        const focusButton = document.getElementById('focusButton'); // Focus button for mobile

        // Canvas dimensions (will be updated dynamically)
        let CANVAS_WIDTH = 480;
        let CANVAS_HEIGHT = 640;
        const CANVAS_ASPECT_RATIO = 3 / 4; // Desired aspect ratio (width / height)

        // Update canvas size based on available space and aspect ratio
        function updateCanvasSize() {
            const gameContainer = document.querySelector('.game-container');
            const containerRect = gameContainer.getBoundingClientRect();

            let availableWidth = containerRect.width - 40; // Account for game-container padding
            let availableHeight = containerRect.height - 40; // Account for game-container padding

            // In landscape, we want canvas to take up less width to make space for controls
            if (window.innerWidth > window.innerHeight) { // Landscape mode
                availableWidth = containerRect.width * 0.6; // Canvas takes up 60% of container width
            }

            let newCanvasWidth = availableWidth;
            let newCanvasHeight = newCanvasWidth / CANVAS_ASPECT_RATIO;

            // If calculated height is too tall for available height, adjust based on height
            if (newCanvasHeight > availableHeight) {
                newCanvasHeight = availableHeight;
                newCanvasWidth = newCanvasHeight * CANVAS_ASPECT_RATIO;
            }

            // Ensure it doesn't exceed original max width for desktop
            if (newCanvasWidth > 480) {
                newCanvasWidth = 480;
                newCanvasHeight = newCanvasWidth / CANVAS_ASPECT_RATIO;
            }

            CANVAS_WIDTH = newCanvasWidth;
            CANVAS_HEIGHT = newCanvasHeight;

            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;

            // Adjust game-container max-width to match canvas only for portrait/desktop
            if (window.innerWidth <= 768 || window.innerWidth <= window.innerHeight) { // Mobile or portrait
                gameContainer.style.maxWidth = `${CANVAS_WIDTH + 40}px`;
            } else { // Desktop landscape
                gameContainer.style.maxWidth = `unset`; // Let it be flexible
            }

            // Reposition player if canvas size changes significantly
            player.x = Math.min(player.x, CANVAS_WIDTH - player.radius);
            player.y = Math.min(player.y, CANVAS_HEIGHT - player.radius);
            player.x = Math.max(player.x, player.radius);
            player.y = Math.max(player.y, player.radius);
        }

        // Create dynamic star background
        function createStars() {
            starBackground.innerHTML = ''; // Clear old stars
            const numStars = 100;
            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.width = `${Math.random() * 3 + 1}px`;
                star.style.height = star.style.width;
                star.style.left = `${Math.random() * 100}%`;
                star.style.top = `${Math.random() * 100}%`;
                star.style.animationDelay = `${Math.random() * 5}s`;
                starBackground.appendChild(star);
            }
        }

        // Call on page load and window resize
        window.addEventListener('load', () => {
            updateCanvasSize();
            createStars();
            // Show start screen on load instead of starting game
            startScreen.style.display = 'flex';
        });
        window.addEventListener('resize', () => {
            updateCanvasSize();
            // Redraw game elements if game is running to adapt to new canvas size
            if (gameRunning && !gamePaused) {
                // No need to restart, just ensure elements are within bounds
                bullets.forEach(b => {
                    b.x = Math.min(b.x, CANVAS_WIDTH + b.radius);
                    b.y = Math.min(b.y, CANVAS_HEIGHT + b.radius);
                });
                enemies.forEach(e => {
                    e.x = Math.min(e.x, CANVAS_WIDTH - e.width / 2);
                    e.y = Math.min(e.y, CANVAS_HEIGHT - e.height / 2);
                });
                artifacts.forEach(a => {
                    a.x = Math.min(a.x, CANVAS_WIDTH - a.radius);
                    a.y = Math.min(a.y, CANVAS_HEIGHT - a.radius);
                });
            }
        });

        // --- Game variables ---
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let startTime = 0;
        let lastFrameTime = 0;
        let difficultyLevel = 1;
        let difficultyTimer = 0;
        let revivesLeft = 3; // Number of revives left (Increased to 3)
        let isInvincible = false; // Invincibility status
        let invincibleTimer = 0;
        const INVINCIBLE_DURATION = 2; // Invincibility duration after revive (seconds)

        let deathCount = 0; // Consecutive deaths
        let scoreAtLastDeath = 0; // Score at last death

        const ASSIST_DEATH_THRESHOLD = 3; // Consecutive deaths to trigger assist
        const ASSIST_SCORE_THRESHOLD = 10; // If score increases less than this threshold after deaths

        const ARTIFACT_SPAWN_INTERVAL = 50; // Artifact appears every 50 points
        let nextArtifactScore = ARTIFACT_SPAWN_INTERVAL;
        const artifacts = []; // Array to hold artifacts


        // --- Player object ---
        const player = {
            x: CANVAS_WIDTH / 2,
            y: CANVAS_HEIGHT - 50,
            radius: 8,
            speed: 10,
            focusSpeedMultiplier: 0.4,
            color: '#00ffff',
            hitboxRadius: 2,
            isFocusing: false
        };

        // --- Bullet and enemy arrays ---
        const bullets = [];
        const enemies = [];

        // --- Keyboard input ---
        const keys = {
            ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
            KeyW: false, KeyA: false, KeyS: false, KeyD: false,
            ShiftLeft: false, ShiftRight: false
        };

        // --- Keyboard event handling ---
        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.code)) { keys[e.code] = true; }
            else if (keys.hasOwnProperty(e.key)) { keys[e.key] = true; }
            if (e.key === 'Escape' || e.code === 'Escape') { togglePause(); }

            // Handle Shift for focus
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                player.isFocusing = true;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.code)) { keys[e.code] = false; }
            else if (keys.hasOwnProperty(e.key)) { keys[e.key] = false; }

            // Handle Shift for focus
            if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') {
                player.isFocusing = false;
            }
        });

        // --- Joystick and mobile control handling ---
        let joystickActive = false;
        let joystickStartX = 0;
        let joystickStartY = 0;
        const joystickMaxDistance = 40; // Max distance handle can move from center

        joystickContainer.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling/zooming
            joystickActive = true;
            const touch = e.touches[0];
            const containerRect = joystickContainer.getBoundingClientRect();
            joystickStartX = containerRect.left + containerRect.width / 2;
            joystickStartY = containerRect.top + containerRect.height / 2;
            moveJoystick(touch.clientX, touch.clientY);
        });

        joystickContainer.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (joystickActive) {
                const touch = e.touches[0];
                moveJoystick(touch.clientX, touch.clientY);
            }
        });

        joystickContainer.addEventListener('touchend', (e) => {
            e.preventDefault();
            joystickActive = false;
            resetJoystick();
            // Reset player movement keys
            keys.ArrowUp = keys.ArrowDown = keys.ArrowLeft = keys.ArrowRight = false;
        });

        joystickContainer.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            joystickActive = false;
            resetJoystick();
            // Reset player movement keys
            keys.ArrowUp = keys.ArrowDown = keys.ArrowLeft = keys.ArrowRight = false;
        });

        function moveJoystick(clientX, clientY) {
            const dx = clientX - joystickStartX;
            const dy = clientY - joystickStartY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            let limitedDx = dx;
            let limitedDy = dy;

            if (distance > joystickMaxDistance) {
                limitedDx = Math.cos(angle) * joystickMaxDistance;
                limitedDy = Math.sin(angle) * joystickMaxDistance;
            }

            joystickHandle.style.transform = `translate(${limitedDx}px, ${limitedDy}px)`;

            // Map joystick movement to player keys
            // Reset all movement keys first
            keys.ArrowUp = keys.ArrowDown = keys.ArrowLeft = keys.ArrowRight = false;

            // Determine direction based on joystick handle position
            if (limitedDy < -10) keys.ArrowUp = true;
            if (limitedDy > 10) keys.ArrowDown = true;
            if (limitedDx < -10) keys.ArrowLeft = true;
            if (limitedDx > 10) keys.ArrowRight = true;
        }

        function resetJoystick() {
            joystickHandle.style.transform = `translate(0, 0)`;
        }

        // Focus button for mobile
        focusButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            player.isFocusing = true;
        });
        focusButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            player.isFocusing = false;
        });
        focusButton.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            player.isFocusing = false;
        });


        // --- Drawing functions ---
        function drawPlayer() {
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fillStyle = player.color;
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Draw small hitbox and make it blink when focusing or invincible
            if (player.isFocusing || isInvincible || (difficultyLevel >= 5 && score % 2 === 0)) {
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.hitboxRadius, 0, Math.PI * 2);
                ctx.fillStyle = isInvincible ? 'rgba(0, 255, 255, 0.5)' : 'rgba(255, 0, 0, 0.7)'; // Cyan when invincible
                ctx.fill();
                ctx.strokeStyle = isInvincible ? 'rgba(255, 255, 255, 0.9)' : 'rgba(255, 255, 255, 0.9)';
                ctx.lineWidth = 1.5;
                ctx.stroke();
            }
        }

        // Bullet trail effect
        const bulletTrails = [];
        function drawBullet(bullet) {
            // Add current bullet position to trail
            bulletTrails.push({ x: bullet.x, y: bullet.y, radius: bullet.radius, color: bullet.color, alpha: 1 });

            // Draw trail points
            for (let i = bulletTrails.length - 1; i >= 0; i--) {
                const trail = bulletTrails[i];
                if (trail.radius < 0.1) { // Remove if too small
                    bulletTrails.splice(i, 1);
                    continue;
                }
                ctx.beginPath();
                ctx.arc(trail.x, trail.y, trail.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${parseInt(trail.color.slice(1, 3), 16)}, ${parseInt(trail.color.slice(3, 5), 16)}, ${parseInt(trail.color.slice(5, 7), 16)}, ${trail.alpha * 0.5})`;
                ctx.fill();
                trail.radius *= 0.9; // Shrink size
                trail.alpha *= 0.9; // Reduce opacity
            }

            // Draw main bullet
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
            ctx.fillStyle = bullet.color;
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        function drawEnemy(enemy) {
            ctx.fillStyle = enemy.color;
            ctx.fillRect(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2, enemy.width, enemy.height);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(enemy.x - enemy.width / 2, enemy.y - enemy.height / 2, enemy.width, enemy.height);
        }

        // --- Artifacts ---
        function createArtifact() {
            const type = Math.floor(Math.random() * 3); // 0: Slow, 1: Speed, 2: Clear
            const x = Math.random() * (CANVAS_WIDTH - 40) + 20;
            const y = Math.random() * (CANVAS_HEIGHT / 2 - 40) + 20; // Only appear in upper half of screen
            artifacts.push({
                x: x,
                y: y,
                radius: 15,
                color: type === 0 ? 'yellow' : (type === 1 ? 'lime' : 'orange'),
                type: type,
                life: 5 // Lasts 5 seconds
            });
        }

        function drawArtifact(artifact) {
            ctx.beginPath();
            ctx.arc(artifact.x, artifact.y, artifact.radius, 0, Math.PI * 2);
            ctx.fillStyle = artifact.color;
            ctx.fill();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'black';
            ctx.font = '12px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            let text = '';
            if (artifact.type === 0) text = 'S'; // Slow
            else if (artifact.type === 1) text = 'F'; // Fast
            else text = 'C'; // Clear
            ctx.fillText(text, artifact.x, artifact.y);
        }

        function updateArtifacts(deltaTime) {
            for (let i = artifacts.length - 1; i >= 0; i--) {
                const artifact = artifacts[i];
                artifact.life -= deltaTime;
                if (artifact.life <= 0) {
                    artifacts.splice(i, 1);
                }
            }
        }

        // --- Update functions ---
        function updatePlayer(deltaTime) {
            // player.isFocusing is now controlled directly by event listeners (keyboard Shift or mobile focus button)
            const currentSpeed = player.isFocusing ? player.speed * player.focusSpeedMultiplier : player.speed;

            if (keys.ArrowUp || keys.KeyW) player.y -= currentSpeed;
            if (keys.ArrowDown || keys.KeyS) player.y += currentSpeed;
            if (keys.ArrowLeft || keys.KeyA) player.x -= currentSpeed;
            if (keys.ArrowRight || keys.KeyD) player.x += currentSpeed;

            player.x = Math.max(player.radius, Math.min(CANVAS_WIDTH - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(CANVAS_HEIGHT - player.radius, player.y));

            // Update invincibility status
            if (isInvincible) {
                invincibleTimer -= deltaTime;
                if (invincibleTimer <= 0) {
                    isInvincible = false;
                    player.color = '#00ffff'; // Revert to original color
                } else {
                    // Blinking effect when invincible
                    player.color = (Math.floor(invincibleTimer * 10) % 2 === 0) ? '#00ffff' : '#ff00ff';
                }
            }
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;

                if (bullet.x < -bullet.radius || bullet.x > CANVAS_WIDTH + bullet.radius ||
                    bullet.y < -bullet.radius || bullet.y > CANVAS_HEIGHT + bullet.radius) {
                    bullets.splice(i, 1);
                }
            }
        }

        function createBullet(x, y, angle, speed, radius, color) {
            bullets.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: radius,
                color: color
            });
        }

        function createEnemy(x, y, width, height, color, shootInterval) {
            enemies.push({
                x: x,
                y: y,
                width: width,
                height: height,
                color: color,
                shootInterval: shootInterval,
                lastShotTime: 0
            });
        }

        // --- Enemy bullet patterns (more complex) ---
        function enemyShoot(enemy, deltaTime) {
            enemy.lastShotTime += deltaTime;

            let bulletSpeed = 4 + difficultyLevel * 0.7; // Slightly reduced bullet speed increase with difficulty
            let bulletRadius = 6 + difficultyLevel * 0.3; // Slightly reduced bullet size increase with difficulty
            let bulletColor = `hsl(${Math.random() * 360}, 100%, 70%)`;

            if (enemy.lastShotTime >= enemy.shootInterval) {
                enemy.lastShotTime = 0;

                // DO NOT clear all old bullets when a new pattern starts to maintain continuity
                // bullets.length = 0;
                // bulletTrails.length = 0;

                const pattern = difficultyLevel % 13; // 13 different bullet patterns (0-12)

                switch (pattern) {
                    case 0: // Simple straight bullet
                        createBullet(enemy.x, enemy.y + enemy.height / 2, Math.PI / 2, bulletSpeed, bulletRadius, bulletColor);
                        break;
                    case 1: // Spread bullets (reduced quantity)
                        const numBulletsSpread = 8 + difficultyLevel * 1.2;
                        for (let i = 0; i < numBulletsSpread; i++) {
                            const angle = Math.PI / 2 - (numBulletsSpread / 2 - i) * (Math.PI / 9); // Wider angle
                            createBullet(enemy.x, enemy.y + enemy.height / 2, angle, bulletSpeed, bulletRadius, bulletColor);
                        }
                        break;
                    case 2: // Spiral bullets (reduced quantity)
                        const spiralSpeed = bulletSpeed * 0.9;
                        const spiralRadius = bulletRadius * 1.0;
                        const numSpiralBullets = 10 + difficultyLevel * 2;
                        for (let i = 0; i < numSpiralBullets; i++) {
                            const angle = (i * (Math.PI * 2 / numSpiralBullets)) + (Date.now() * 0.001 * (difficultyLevel * 0.1));
                            createBullet(enemy.x, enemy.y + enemy.height / 2, angle, spiralSpeed, spiralRadius, bulletColor);
                        }
                        break;
                    case 3: // Aimed bullet
                        const angleToPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        createBullet(enemy.x, enemy.y + enemy.height / 2, angleToPlayer, bulletSpeed * 1.3, bulletRadius, bulletColor);
                        break;
                    case 4: // Wave bullets (reduced amplitude and frequency)
                        const waveSpeed = bulletSpeed * 0.8;
                        const waveAmplitude = 12 + difficultyLevel * 2;
                        const waveFrequency = 0.07;
                        for (let i = 0; i < 5; i++) {
                            const offsetY = Math.sin((enemy.x + i * 40) * waveFrequency + Date.now() * 0.002) * waveAmplitude;
                            createBullet(enemy.x + i * 30 - 60, enemy.y + enemy.height / 2 + offsetY, Math.PI / 2, waveSpeed, bulletRadius, bulletColor);
                        }
                        break;
                    case 5: // Aimed fan bullets (reduced quantity)
                        const fanAngle = Math.PI / 5;
                        const baseAngleToPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        for (let i = -1; i <= 1; i++) { // 3 bullets
                            createBullet(enemy.x, enemy.y + enemy.height / 2, baseAngleToPlayer + i * fanAngle / 2, bulletSpeed * 1.1, bulletRadius, bulletColor);
                        }
                        break;
                    case 6: // Bullet wall with gap (reduced quantity)
                        const wallBulletCount = 15;
                        const gapSize = bulletRadius * 4; // Larger gap size
                        const gapPosition = Math.floor(Math.random() * (wallBulletCount - 2));
                        for (let i = 0; i < wallBulletCount; i++) {
                            if (i !== gapPosition && i !== gapPosition + 1) {
                                const bulletX = (CANVAS_WIDTH / wallBulletCount) * i + (CANVAS_WIDTH / wallBulletCount / 2);
                                createBullet(bulletX, enemy.y + enemy.height / 2, Math.PI / 2, bulletSpeed * 0.8, bulletRadius, bulletColor);
                            }
                        }
                        break;
                    case 7: // "Flower" bullets (reduced quantity per layer)
                        const innerBullets = 5 + difficultyLevel * 0.8;
                        const middleBullets = 10 + difficultyLevel * 1.2;
                        const outerBullets = 15 + difficultyLevel * 1.5;
                        for (let i = 0; i < innerBullets; i++) {
                            const angle = (i * (Math.PI * 2 / innerBullets));
                            createBullet(enemy.x, enemy.y + enemy.height / 2, angle, bulletSpeed * 0.6, bulletRadius * 0.7, bulletColor);
                        }
                        for (let i = 0; i < middleBullets; i++) {
                            const angle = (i * (Math.PI * 2 / middleBullets)) + (Math.PI / middleBullets / 2);
                            createBullet(enemy.x, enemy.y + enemy.height / 2, angle, bulletSpeed * 0.8, bulletRadius * 0.9, bulletColor);
                        }
                        for (let i = 0; i < outerBullets; i++) {
                            const angle = (i * (Math.PI * 2 / outerBullets)) + (Math.PI / outerBullets);
                            createBullet(enemy.x, enemy.y + enemy.height / 2, angle, bulletSpeed * 1.0, bulletRadius * 1.1, bulletColor);
                        }
                        break;
                    case 8: // Chaotic random bullets (reduced quantity and speed)
                        const chaoticBulletCount = 10 + difficultyLevel * 2;
                        for (let i = 0; i < chaoticBulletCount; i++) {
                            const randomAngle = Math.random() * Math.PI * 2;
                            const randomSpeed = bulletSpeed * (0.4 + Math.random() * 0.3);
                            const randomRadius = bulletRadius * (0.6 + Math.random() * 0.2);
                            createBullet(enemy.x, enemy.y + enemy.height / 2, randomAngle, randomSpeed, randomRadius, bulletColor);
                        }
                        break;
                    case 9: // Barrage (reduced quantity and speed)
                        const barrageCount = 1 + difficultyLevel * 0.5;
                        const barrageSpread = Math.PI / 5;
                        const barrageSpeed = bulletSpeed * 1.0;
                        const barrageDelay = 0.08;

                        for (let i = 0; i < barrageCount; i++) {
                            const angleOffset = (Math.random() - 0.5) * barrageSpread;
                            const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x) + angleOffset;
                            setTimeout(() => {
                                createBullet(enemy.x, enemy.y + enemy.height / 2, angle, barrageSpeed, bulletRadius * 0.7, 'red');
                            }, i * barrageDelay * 1000);
                        }
                        break;
                    case 10: // Vertical bullets (reduced quantity)
                        const verticalBulletCount = 3 + difficultyLevel * 0.8;
                        const verticalBulletSpacing = CANVAS_WIDTH / (verticalBulletCount + 1);
                        for (let i = 0; i < verticalBulletCount; i++) {
                            const bulletX = (i + 1) * verticalBulletSpacing;
                            createBullet(bulletX, enemy.y + enemy.height / 2, Math.PI / 2, bulletSpeed * 0.5, bulletRadius, 'purple');
                        }
                        break;
                    case 11: // New pattern: Rotating diagonal bullets (reduced rotation speed)
                        const crossBulletCount = 4;
                        const rotationSpeed = 0.0003 * difficultyLevel;
                        const baseAngle = Date.now() * rotationSpeed;
                        for (let i = 0; i < crossBulletCount; i++) {
                            const angle = baseAngle + (i * Math.PI / 2);
                            createBullet(enemy.x, enemy.y + enemy.height / 2, angle, bulletSpeed * 0.8, bulletRadius, 'orange');
                        }
                        break;
                    case 12: // New pattern: Zig-zag bullets (reduced amplitude and frequency)
                        const zigzagBulletCount = 4 + difficultyLevel * 0.8;
                        const zigzagAmplitude = 15 + difficultyLevel * 2;
                        const zigzagFrequency = 0.04;
                        for (let i = 0; i < zigzagBulletCount; i++) {
                            const bulletXOffset = Math.sin(i * zigzagFrequency + Date.now() * 0.002) * zigzagAmplitude;
                            createBullet(enemy.x + bulletXOffset, enemy.y + enemy.height / 2, Math.PI / 2, bulletSpeed * 0.6, bulletRadius, 'cyan');
                        }
                        break;
                }
            }
        }

        // --- Collision detection (circle vs circle) ---
        function checkCollision(circle1, circle2) {
            const dx = circle1.x - circle2.x;
            const dy = circle1.y - circle2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < circle1.radius + circle2.radius;
        }

        // --- Background music (using Tone.js) ---
        let synth;
        let bassSynth;
        let drumSynth;
        let reverb;
        let delay;
        let masterGain;
        let melodyLoop;
        let bassLoop;
        let drumLoop;
        let isMusicPlaying = false;

        function initMusic() {
            if (!synth) {
                // Reverb and Delay effects
                reverb = new Tone.Reverb(2).toDestination();
                delay = new Tone.FeedbackDelay("8n", 0.5).toDestination();

                // Synth for main melody
                synth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.4, release: 0.8 }
                }).chain(reverb, delay, Tone.Destination);

                // Synth for bassline
                bassSynth = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 1.2 }
                }).chain(reverb, Tone.Destination);

                // Synth for simple drums (kick and snare)
                drumSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.05,
                    octaves: 10,
                    envelope: {
                        attack: 0.001,
                        decay: 0.4,
                        sustain: 0.01,
                        release: 1.4,
                        attackCurve: "exponential"
                    }
                }).toDestination();

                masterGain = new Tone.Gain(0.4).toDestination();
                synth.connect(masterGain);
                bassSynth.connect(masterGain);
                drumSynth.connect(masterGain);

                // Main melody
                const melodyNotes = [
                    "C4", "E4", "G4", "A4",
                    "G4", "E4", "C4", "F4",
                    "E4", "G4", "C5", "A4",
                    "G4", "E4", "D4", "C4"
                ];
                let melodyIndex = 0;
                melodyLoop = new Tone.Loop((time) => {
                    synth.triggerAttackRelease(melodyNotes[melodyIndex % melodyNotes.length], "8n", time);
                    melodyIndex++;
                }, "4n").start(0);

                // Bassline
                const bassNotes = ["C2", "C2", "F2", "F2", "G2", "G2", "C2", "C2"];
                let bassIndex = 0;
                bassLoop = new Tone.Loop((time) => {
                    bassSynth.triggerAttackRelease(bassNotes[bassIndex % bassNotes.length], "2n", time);
                    bassIndex++;
                }, "2n").start(0);

                // Simple drum beat
                const drumPattern = [
                    ["C1"], [], ["C1"], [],
                    ["C1"], [], ["C1"], [],
                    ["C1"], [], ["C1"], [],
                    ["C1"], [], ["C1"], []
                ]; // Kick drum on quarter notes
                let drumIndex = 0;
                drumLoop = new Tone.Sequence((time, note) => {
                    drumSynth.triggerAttackRelease(note, "16n", time);
                }, drumPattern, "8n").start(0); // Every 1/8th note

                Tone.Transport.bpm.value = 140;
            }
        }

        async function toggleMusic() {
            await Tone.start();
            initMusic();

            if (isMusicPlaying) {
                Tone.Transport.stop();
                musicToggleButton.textContent = 'Toggle Music';
                masterGain.gain.linearRampToValueAtTime(0, Tone.context.currentTime + 0.5);
            } else {
                Tone.Transport.start();
                musicToggleButton.textContent = 'Toggle Music';
                masterGain.gain.linearRampToValueAtTime(0.4, Tone.context.currentTime + 0.5);
            }
            isMusicPlaying = !isMusicPlaying;
        }

        // --- Sound effects (SFX) ---
        let hitSynth;
        let difficultyUpSynth;
        let artifactCollectSynth; // SFX for artifacts

        function initSFX() {
            // Initialize only once
            if (!hitSynth) {
                hitSynth = new Tone.NoiseSynth({
                    envelope: {
                        attack: 0.001,
                        decay: 0.1,
                        sustain: 0,
                        release: 0.1
                    },
                    noise: { type: 'white' }
                }).toDestination();
                hitSynth.volume.value = -10; // Reduce volume
            }
            if (!difficultyUpSynth) {
                difficultyUpSynth = new Tone.Synth({
                    oscillator: { type: 'square' },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.0, release: 0.2 }
                }).toDestination();
                difficultyUpSynth.volume.value = -10; // Reduce volume
            }
            if (!artifactCollectSynth) {
                artifactCollectSynth = new Tone.Synth({
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.005, decay: 0.05, sustain: 0.0, release: 0.1 }
                }).toDestination();
                artifactCollectSynth.volume.value = -8; // Increase artifact SFX volume
            }
        }

        async function playHitSFX() {
            await Tone.start();
            hitSynth.triggerAttackRelease("C3", "8n");
        }

        async function playDifficultyUpSFX() {
            await Tone.start();
            difficultyUpSynth.triggerAttackRelease("C5", "16n", Tone.now());
            difficultyUpSynth.triggerAttackRelease("G5", "16n", Tone.now() + 0.1);
        }

        async function playArtifactCollectSFX() {
            await Tone.start();
            artifactCollectSynth.triggerAttackRelease("E6", "16n");
            artifactCollectSynth.triggerAttackRelease("G6", "16n", Tone.now() + 0.05);
        }

        // --- Assist function ---
        function triggerAssist() {
            bullets.length = 0; // Clear all bullets
            bulletTrails.length = 0; // Clear bullet trails
            isInvincible = true;
            invincibleTimer = INVINCIBLE_DURATION * 1.5; // Increase invincibility duration when assisting
            player.x = CANVAS_WIDTH / 2;
            player.y = CANVAS_HEIGHT - 50; // Move player to safe position
            playDifficultyUpSFX(); // Play assist sound
            console.log("Assist Mode Activated!");
        }

        // --- Pause/Resume game function ---
        function togglePause() {
            if (!gameRunning) return;

            gamePaused = !gamePaused;
            if (gamePaused) {
                pauseButton.textContent = 'Resume';
                pausedOverlay.style.display = 'flex';
                if (isMusicPlaying) {
                    Tone.Transport.pause();
                    masterGain.gain.linearRampToValueAtTime(0, Tone.context.currentTime + 0.2);
                }
            } else {
                pauseButton.textContent = 'Pause';
                pausedOverlay.style.display = 'none';
                lastFrameTime = performance.now();
                if (isMusicPlaying) {
                    Tone.Transport.start();
                    masterGain.gain.linearRampToValueAtTime(0.4, Tone.context.currentTime + 0.2);
                }
                requestAnimationFrame(gameLoop);
            }
        }

        // --- Main game loop ---
        function gameLoop(currentTime) {
            if (!gameRunning || gamePaused) return;

            const deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;

            score = Math.floor((currentTime - startTime) / 1000);
            scoreDisplay.textContent = `Score: ${score}`;

            // Create artifact
            if (score >= nextArtifactScore) {
                createArtifact();
                nextArtifactScore += ARTIFACT_SPAWN_INTERVAL;
            }

            difficultyTimer += deltaTime;
            const difficultyIncreaseInterval = 4;
            if (difficultyTimer >= difficultyIncreaseInterval) {
                difficultyLevel++;
                difficultyTimer = 0;
                difficultyDisplay.textContent = `Difficulty: ${difficultyLevel}`;
                enemies.forEach(enemy => {
                    enemy.shootInterval = Math.max(0.04, enemy.shootInterval * 0.8);
                });
                playDifficultyUpSFX(); // Play SFX when difficulty increases
            }

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            updatePlayer(deltaTime);
            drawPlayer();

            updateBullets();
            bullets.forEach(drawBullet);

            updateArtifacts(deltaTime);
            artifacts.forEach(drawArtifact);

            enemies.forEach(enemy => {
                drawEnemy(enemy);
                enemyShoot(enemy, deltaTime);
            });

            // Check player-bullet collision
            if (!isInvincible) {
                for (let i = 0; i < bullets.length; i++) {
                    if (checkCollision({ x: player.x, y: player.y, radius: player.hitboxRadius }, bullets[i])) {
                        playHitSFX(); // Play SFX when hit

                        // Check assist conditions
                        deathCount++;
                        if (deathCount >= ASSIST_DEATH_THRESHOLD && (score - scoreAtLastDeath < ASSIST_SCORE_THRESHOLD)) {
                             triggerAssist();
                             deathCount = 0; // Reset death counter after assist
                             scoreAtLastDeath = score; // Update score at assist
                        } else if (revivesLeft > 0) {
                            revivesLeft--;
                            revivesDisplay.textContent = `Revives: ${revivesLeft}`;
                            isInvincible = true;
                            invincibleTimer = INVINCIBLE_DURATION;
                            player.x = CANVAS_WIDTH / 2;
                            player.y = CANVAS_HEIGHT - 50;
                            bullets.length = 0;
                            bulletTrails.length = 0; // Clear bullet trails
                            scoreAtLastDeath = score; // Update score at revive
                        } else {
                            gameOver();
                            return;
                        }
                        break; // Exit loop to avoid multiple collisions
                    }
                }
            }

            // Check player-artifact collision
            for (let i = artifacts.length - 1; i >= 0; i--) {
                const artifact = artifacts[i];
                if (checkCollision(player, artifact)) {
                    playArtifactCollectSFX(); // Play SFX when collecting artifact
                    // Activate artifact effect
                    if (artifact.type === 0) { // Slow
                        bullets.forEach(b => b.speed *= 0.6); // Slow down existing bullets
                        setTimeout(() => {
                            bullets.forEach(b => b.speed /= 0.6); // Revert to original speed
                        }, 3000); // Lasts 3 seconds
                    } else if (artifact.type === 1) { // Speed
                        player.speed *= 1.5; // Increase player speed
                        setTimeout(() => {
                            player.speed /= 1.5; // Revert to original speed
                        }, 3000); // Lasts 3 seconds
                    } else if (artifact.type === 2) { // Clear
                        bullets.length = 0; // Clear all bullets on screen
                        bulletTrails.length = 0;
                    }
                    artifacts.splice(i, 1); // Remove collected artifact
                }
            }


            requestAnimationFrame(gameLoop);
        }

        // --- Start game function ---
        async function startGame() {
            updateCanvasSize(); // Update canvas size before starting
            createStars();
            gameRunning = true;
            gamePaused = false;
            score = 0;
            difficultyLevel = 1;
            difficultyTimer = 0;
            revivesLeft = 3; // Reset revives
            isInvincible = false;
            invincibleTimer = 0;
            deathCount = 0; // Reset death count
            scoreAtLastDeath = 0; // Reset score at death
            nextArtifactScore = ARTIFACT_SPAWN_INTERVAL; // Reset artifact spawn threshold
            startTime = performance.now();
            lastFrameTime = startTime;

            player.x = CANVAS_WIDTH / 2;
            player.y = CANVAS_HEIGHT - 50;
            player.color = '#00ffff';
            player.isFocusing = false;
            player.speed = 10; // Ensure player speed is reset

            bullets.length = 0;
            enemies.length = 0;
            bulletTrails.length = 0;
            artifacts.length = 0; // Clear all artifacts

            createEnemy(CANVAS_WIDTH / 2, 50, 60, 60, '#ff00ff', 0.8);

            gameOverScreen.style.display = 'none';
            pausedOverlay.style.display = 'none';
            startScreen.style.display = 'none'; // Hide start screen
            scoreDisplay.textContent = `Score: 0`;
            difficultyDisplay.textContent = `Difficulty: 1`;
            revivesDisplay.textContent = `Revives: ${revivesLeft}`;
            pauseButton.textContent = 'Pause';
            musicToggleButton.textContent = 'Toggle Music'; // Ensure button text is correct

            initMusic();
            initSFX();
            if (!isMusicPlaying) {
                await toggleMusic();
            } else {
                if (Tone.Transport.state === 'paused' || Tone.Transport.state === 'stopped') {
                    Tone.Transport.start();
                }
                masterGain.gain.linearRampToValueAtTime(0.4, Tone.context.currentTime + 0.2);
            }

            requestAnimationFrame(gameLoop);
        }

        // --- Game over function ---
        function gameOver() {
            gameRunning = false;
            gamePaused = true;
            finalScoreDisplay.textContent = score;
            gameOverScreen.style.display = 'flex';
            if (isMusicPlaying) {
                Tone.Transport.stop();
                masterGain.gain.linearRampToValueAtTime(0, Tone.context.currentTime + 0.5);
            }
        }

        // --- Event Listeners for buttons ---
        startButton.addEventListener('click', startGame); // New start button listener
        restartButton.addEventListener('click', startGame);
        pauseButton.addEventListener('click', togglePause);
        musicToggleButton.addEventListener('click', toggleMusic);

        // Initial setup on window load is handled by the 'load' event listener
    </script>
</body>
</html>
